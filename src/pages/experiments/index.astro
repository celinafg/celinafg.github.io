---
import { getCollection } from "astro:content";
import Layout from "../../layouts/Layout.astro";

const allExperiments = await getCollection("experiments");

const experiments = import.meta.env.PROD
  ? allExperiments.filter((experiment) => !experiment.data.draft)
  : allExperiments;

const allTags = [
  ...new Set(experiments.flatMap((experiment) => experiment.data.tags || [])),
].sort();
---

<Layout title="experiments & Experiments" withCont={true} pageType="experiment">
  <div class="experiments-container">
    <div class="header-title">
      <h2>Experiments, side projects, and creative explorations</h2>
      <p>You'll find a mix of 3d printing, hardware, software, and design</p>

      {/* Tag filter section */}
      <div class="tag-filter-section">
        <button class="tag-filter active" data-tag="all">All</button>
        {
          allTags.map((tag) => (
            <button class="tag-filter" data-tag={tag}>
              {tag}
            </button>
          ))
        }
      </div>
    </div>

    <div class="gallery-grid">
      {
        experiments.map((experiment, index) => (
          <div
            class="gallery-item"
            data-experiment-index={index}
            data-tags={JSON.stringify(experiment.data.tags || [])}
          >
            <div class="item-inner">
              {experiment.data.imageCover && (
                <img
                  src={experiment.data.imageCover}
                  alt={experiment.data.title}
                  loading="lazy"
                  class="gallery-image"
                />
              )}
            </div>
          </div>
        ))
      }
    </div>
  </div>

  <div id="article-modal" class="article-modal">
    <button id="close-modal" class="close-modal-btn" aria-label="Close gallery">
      <svg
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          d="M18 6L6 18M6 6L18 18"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"></path>
      </svg>
    </button>

    <button
      id="prev-article"
      class="nav-arrow prev"
      aria-label="Previous article"
    >
      <svg
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          d="M15 18L9 12L15 6"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"></path>
      </svg>
    </button>

    <button id="next-article" class="nav-arrow next" aria-label="Next article">
      <svg
        width="24"
        height="24"
        viewBox="0 0 24 24"
        fill="none"
        xmlns="http://www.w3.org/2000/svg"
      >
        <path
          d="M9 18L15 12L9 6"
          stroke="currentColor"
          stroke-width="2"
          stroke-linecap="round"
          stroke-linejoin="round"></path>
      </svg>
    </button>

    <div class="modal-content">
      <div class="modal-inner">
        {
          experiments.map((experiment, index) => (
            <div
              class="article-content"
              data-article-index={index}
              style="display: none;"
            >
              <div class="split-container">
                <div class="image-section">
                  {experiment.data.imageCover && (
                    <img
                      src={experiment.data.imageCover}
                      alt={experiment.data.title}
                      class="modal-main-image"
                    />
                  )}
                </div>

                <div class="info-section">
                  <div class="info-inner">
                    <header class="modal-header">
                      <h1>{experiment.data.title}</h1>
                      <div class="modal-tags-container">
                        {experiment.data.type && (
                          <span class="modal-type">{experiment.data.type}</span>
                        )}
                        {experiment.data.tags &&
                          experiment.data.tags.length > 0 && (
                            <div class="modal-tags">
                              {experiment.data.tags.map((tag: string) => (
                                <span class="modal-tag">{tag}</span>
                              ))}
                            </div>
                          )}
                      </div>
                    </header>

                    <div class="modal-description">
                      {experiment.data.description && (
                        <p>{experiment.data.description}</p>
                      )}
                    </div>

                    <div class="modal-footer">
                      <a
                        href={`/experiments/${experiment.slug}`}
                        class="full-article-btn"
                      >
                        View Full Project
                      </a>
                      {experiment.data.link && (
                        <a
                          href={experiment.data.link}
                          target="_blank"
                          rel="noopener noreferrer"
                          class="external-link-btn"
                        >
                          <span>Visit Live Project</span>
                          <svg
                            width="16"
                            height="16"
                            viewBox="0 0 24 24"
                            fill="none"
                            xmlns="http://www.w3.org/2000/svg"
                          >
                            <path
                              d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6M15 3h6v6M10 14L21 3"
                              stroke="currentColor"
                              stroke-width="2"
                              stroke-linecap="round"
                              stroke-linejoin="round"
                            />
                          </svg>
                        </a>
                      )}
                    </div>
                  </div>
                </div>
              </div>
            </div>
          ))
        }
      </div>
    </div>

    <div class="swipe-indicator">
      <div class="indicator-dot"></div>
      <div class="indicator-text">Swipe to navigate</div>
    </div>
  </div>
</Layout>

<style>
  .experiments-container {
    max-width: 1400px;
    margin: 0 auto;
    padding: 3rem 1rem;
    background-color: #ffffff;
    color: #1a1a1a;
  }

  .experiments-header {
    padding: 5rem 0 4rem;
    position: relative;
  }

  .overline {
    font-family: "Inter", sans-serif;
    font-size: 0.75rem;
    letter-spacing: 0.1em;
    margin-bottom: 1rem;
    color: #888;
    font-weight: 500;
    text-transform: uppercase;
  }

  .header-title {
    h2 {
      font-size: 2.2rem;
      margin: 2rem 0;
    }

    max-width: 700px;
    font-weight: 300;
    color: #1a1a1a;
    padding: 1rem;
    min-height: 30vh;
    height: 50vh;
  }

  /* Tag filter styles */
  .tag-filter-section {
    margin-top: 2rem;
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    padding: 1rem 0;
  }

  .tag-filter {
    background: #f5f5f5;
    border: 1px solid #e0e0e0;
    padding: 0.5rem 1rem;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 0.875rem;
    color: #666;
  }

  .tag-filter:hover {
    background: #ebebeb;
  }

  .tag-filter.active {
    background: #1a1a1a;
    color: white;
    border-color: #1a1a1a;
  }

  .gallery-grid {
    column-count: 3;
    column-gap: 1rem;
    padding: 2rem 0;
  }

  .gallery-item {
    break-inside: avoid;
    margin-bottom: 1rem;
    cursor: pointer;
    transition: opacity 0.3s ease;
  }

  .gallery-item:hover {
    opacity: 0.85;
  }

  .gallery-item.hidden {
    display: none;
  }

  .item-inner {
    position: relative;
    overflow: hidden;
  }

  .gallery-image {
    width: 100%;
    height: auto;
    display: block;
    border-radius: 8px;
  }

  /* Tags on gallery items */
  .item-tags {
    position: absolute;
    bottom: 8px;
    left: 8px;
    right: 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    pointer-events: none;
  }

  .tag-chip {
    background: rgba(255, 255, 255, 0.9);
    padding: 2px 6px;
    border-radius: 4px;
    font-size: 0.75rem;
    color: #333;
    backdrop-filter: blur(4px);
  }

  /* Article Modal Styles */
  .article-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    z-index: 10000;
    opacity: 0;
    visibility: hidden;
    transition:
      opacity 0.3s ease,
      visibility 0.3s ease;
  }

  .article-modal.active {
    opacity: 1;
    visibility: visible;
  }

  /* Hide background scrollbar when modal is active */
  body:has(.article-modal.active) {
    overflow: hidden !important;
  }

  /* For browsers that don't support :has() */
  .modal-open {
    overflow: hidden !important;
  }

  .close-modal-btn {
    position: fixed;
    top: 2rem;
    right: 2rem;
    background: rgba(255, 255, 255, 0.1);
    border: none;
    color: white;
    width: 48px;
    height: 48px;
    border-radius: 50%;
    cursor: pointer;
    z-index: 20;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: background 0.3s ease;
  }

  .close-modal-btn:hover {
    background: rgba(255, 255, 255, 0.2);
  }

  /* Navigation arrows */
  .nav-arrow {
    position: fixed;
    top: 50%;
    transform: translateY(-50%);
    background: rgba(255, 255, 255, 0.1);
    border: none;
    color: white;
    width: 56px;
    height: 56px;
    border-radius: 8px;
    cursor: pointer;
    z-index: 20;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.3s ease;
    backdrop-filter: blur(10px);
  }

  .nav-arrow:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-50%) scale(1.1);
  }

  .nav-arrow.prev {
    left: 2rem;
  }

  .nav-arrow.next {
    right: 2rem;
  }

  .modal-content {
    width: 100%;
    height: 100vh;
    position: relative;
    overflow: hidden;
  }

  .modal-inner {
    width: 100%;
    height: 100%;
    position: relative;
  }

  .article-content {
    width: 100%;
    height: 100vh;
    position: absolute;
    top: 0;
    left: 0;
  }

  .split-container {
    display: grid;
    grid-template-columns: 1fr 1fr;
    height: 100vh;
    overflow: hidden;
  }

  .image-section {
    position: relative;
    overflow: hidden;
    background: #000;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .modal-main-image {
    max-width: 100%;
    max-height: 100%;
    width: auto;
    height: auto;
    object-fit: contain;
  }

  .info-section {
    background: rgba(0, 0, 0, 0.95);
    color: white;
    display: flex;
    flex-direction: column;
    justify-content: center;
    padding: 4rem;
    overflow-y: auto;
  }

  .info-inner {
    max-width: 500px;
    width: 100%;
  }

  .modal-header {
    margin-bottom: 2rem;
  }

  .modal-header h1 {
    font-size: 2.5rem;
    margin-bottom: 1rem;
    font-weight: 300;
    line-height: 1.2;
  }

  .modal-tags-container {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
    align-items: center;
  }

  .modal-type {
    display: inline-block;
    background: rgba(255, 255, 255, 0.1);
    padding: 0.5rem 1rem;
    border-radius: 4px;
    font-size: 0.875rem;
    color: rgba(255, 255, 255, 0.9);
  }

  .modal-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 0.5rem;
  }

  .modal-tag {
    background: rgba(255, 255, 255, 0.1);
    padding: 0.25rem 0.75rem;
    border-radius: 4px;
    font-size: 0.8rem;
    color: rgba(255, 255, 255, 0.8);
    border: 1px solid rgba(255, 255, 255, 0.1);
  }

  .modal-description {
    margin-bottom: 3rem;
  }

  .modal-description p {
    font-size: 1.125rem;
    line-height: 1.6;
    color: rgba(255, 255, 255, 0.8);
    margin: 0;
  }

  .modal-footer {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
  }

  .full-article-btn,
  .external-link-btn {
    display: inline-flex;
    align-items: center;
    gap: 0.5rem;
    background: rgba(255, 255, 255, 0.1);
    color: white;
    padding: 0.75rem 1.5rem;
    border-radius: 4px;
    text-decoration: none;
    transition: all 0.3s ease;
    border: 1px solid rgba(255, 255, 255, 0.2);
  }

  .full-article-btn {
    background: white;
    color: #000;
    border-color: white;
  }

  .full-article-btn:hover {
    background: rgba(255, 255, 255, 0.9);
    transform: translateY(-2px);
  }

  .external-link-btn:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: translateY(-2px);
  }

  .external-link-btn svg {
    transition: transform 0.3s ease;
  }

  .external-link-btn:hover svg {
    transform: translate(2px, -2px);
  }

  /* Swipe indicator */
  .swipe-indicator {
    position: fixed;
    bottom: 2rem;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    align-items: center;
    gap: 0.5rem;
    color: rgba(255, 255, 255, 0.6);
    font-size: 0.875rem;
    z-index: 15;
    opacity: 1;
    transition: opacity 0.3s ease;
  }

  .indicator-dot {
    width: 6px;
    height: 6px;
    background: rgba(255, 255, 255, 0.6);
    border-radius: 50%;
    animation: pulse 2s infinite;
  }

  @keyframes pulse {
    0% {
      opacity: 0.3;
    }
    50% {
      opacity: 1;
    }
    100% {
      opacity: 0.3;
    }
  }

  /* Responsive styles */
  @media (max-width: 768px) {
    .experiments-container {
      padding: 0 1rem;
    }

    .experiments-header {
      margin: 3rem 0 2rem;
    }

    .header-title {
      font-size: 1.75rem;
    }

    .gallery-grid {
      column-count: 2;
    }

    .close-modal-btn {
      top: 1rem;
      right: 1rem;
      width: 40px;
      height: 40px;
    }

    .nav-arrow {
      width: 44px;
      height: 44px;
    }

    .nav-arrow.prev {
      left: 1rem;
    }

    .nav-arrow.next {
      right: 1rem;
    }

    /* Stack layout on mobile */
    .split-container {
      grid-template-columns: 1fr;
      grid-template-rows: 60% 40%;
    }

    .info-section {
      padding: 2rem;
      justify-content: flex-start;
    }

    .modal-header h1 {
      font-size: 1.75rem;
    }

    .modal-description {
      margin-bottom: 2rem;
    }
  }

  @media (max-width: 480px) {
    .gallery-grid {
      column-count: 1;
    }

    .split-container {
      grid-template-rows: 50% 50%;
    }

    .info-section {
      padding: 1.5rem;
    }

    .modal-header h1 {
      font-size: 1.5rem;
    }

    .modal-description p {
      font-size: 1rem;
    }

    .tag-filter-section {
      gap: 0.25rem;
    }

    .tag-filter {
      padding: 0.4rem 0.8rem;
      font-size: 0.8rem;
    }
  }
</style>

<script>
  document.addEventListener("DOMContentLoaded", (): void => {
    // Tag filtering functionality
    const tagFilters: NodeListOf<HTMLButtonElement> =
      document.querySelectorAll(".tag-filter");
    const galleryItems: NodeListOf<HTMLElement> =
      document.querySelectorAll(".gallery-item");

    tagFilters.forEach((filter: HTMLButtonElement) => {
      filter.addEventListener("click", () => {
        // Update active state
        tagFilters.forEach((f) => f.classList.remove("active"));
        filter.classList.add("active");

        const selectedTag = filter.dataset.tag;

        // Filter gallery items
        galleryItems.forEach((item: HTMLElement) => {
          if (selectedTag === "all") {
            item.classList.remove("hidden");
          } else {
            const itemTags = JSON.parse(item.dataset.tags || "[]");
            if (itemTags.includes(selectedTag)) {
              item.classList.remove("hidden");
            } else {
              item.classList.add("hidden");
            }
          }
        });
      });
    });

    // Gallery item click handlers
    const articleModal: HTMLElement | null =
      document.getElementById("article-modal");
    const closeModalBtn: HTMLElement | null =
      document.getElementById("close-modal");
    const prevBtn: HTMLElement | null = document.getElementById("prev-article");
    const nextBtn: HTMLElement | null = document.getElementById("next-article");
    const articles: NodeListOf<HTMLElement> =
      document.querySelectorAll(".article-content");
    const swipeIndicator: HTMLElement | null =
      document.querySelector(".swipe-indicator");

    let currentArticleIndex: number = 0;
    let isTransitioning: boolean = false;
    let originalBodyOverflow: string = "";
    let originalBodyPaddingRight: string = "";

    function openModal(index: number): void {
      if (!articleModal || isTransitioning) return;

      isTransitioning = true;

      // Prevent body scroll and hide scrollbar completely
      originalBodyOverflow = document.body.style.overflow;
      originalBodyPaddingRight = document.body.style.paddingRight;

      // Calculate scrollbar width to prevent layout shift
      const scrollBarWidth =
        window.innerWidth - document.documentElement.clientWidth;

      // Apply styles to hide scrollbar and prevent shift
      document.documentElement.style.overflow = "hidden";
      document.body.style.overflow = "hidden";
      document.body.style.paddingRight = `${scrollBarWidth}px`;
      document.body.classList.add("modal-open");

      // Hide all articles
      articles.forEach((article: HTMLElement) => {
        article.style.display = "none";
      });

      // Show selected article
      const selectedArticle: HTMLElement | null = articles[index];
      if (selectedArticle) {
        selectedArticle.style.display = "block";
        currentArticleIndex = index;
      }

      // Open modal
      articleModal.classList.add("active");

      // Hide swipe indicator after first interaction
      setTimeout(() => {
        if (swipeIndicator) {
          swipeIndicator.style.opacity = "0";
        }
      }, 3000);

      setTimeout(() => {
        isTransitioning = false;
      }, 300);
    }

    function closeModal(): void {
      if (!articleModal || isTransitioning) return;

      // Restore body scroll and remove scrollbar hiding
      document.documentElement.style.overflow = "";
      document.body.style.overflow = originalBodyOverflow;
      document.body.style.paddingRight = originalBodyPaddingRight;
      document.body.classList.remove("modal-open");

      articleModal.classList.remove("active");

      // Reset swipe indicator
      if (swipeIndicator) {
        swipeIndicator.style.opacity = "1";
      }
    }

    function goToNextArticle(): void {
      if (isTransitioning) return;

      // Only navigate through visible items
      const visibleItems = Array.from(galleryItems).filter(
        (item) => !item.classList.contains("hidden")
      );
      if (visibleItems.length === 0) return;

      // Find the index of the current item in visible items
      const currentVisibleIndex = visibleItems.findIndex(
        (item) =>
          parseInt(item.dataset.experimentIndex || "0") === currentArticleIndex
      );

      // Calculate next visible index
      let nextVisible = (currentVisibleIndex + 1) % visibleItems.length;
      let nextIndex = parseInt(
        visibleItems[nextVisible].dataset.experimentIndex || "0"
      );

      openModal(nextIndex);
    }

    function goToPrevArticle(): void {
      if (isTransitioning) return;

      // Only navigate through visible items
      const visibleItems = Array.from(galleryItems).filter(
        (item) => !item.classList.contains("hidden")
      );
      if (visibleItems.length === 0) return;

      // Find the index of the current item in visible items
      const currentVisibleIndex = visibleItems.findIndex(
        (item) =>
          parseInt(item.dataset.experimentIndex || "0") === currentArticleIndex
      );

      // Calculate previous visible index
      let prevVisible =
        (currentVisibleIndex - 1 + visibleItems.length) % visibleItems.length;
      let prevIndex = parseInt(
        visibleItems[prevVisible].dataset.experimentIndex || "0"
      );

      openModal(prevIndex);
    }

    // Add click handlers to gallery items
    galleryItems.forEach((item: HTMLElement, index: number) => {
      item.addEventListener("click", () => {
        openModal(index);
      });
    });

    // Navigation button handlers
    if (nextBtn) {
      nextBtn.addEventListener("click", goToNextArticle);
    }

    if (prevBtn) {
      prevBtn.addEventListener("click", goToPrevArticle);
    }

    // Close modal button
    if (closeModalBtn) {
      closeModalBtn.addEventListener("click", closeModal);
    }

    // Close on escape key
    document.addEventListener("keydown", (e: KeyboardEvent) => {
      if (e.key === "Escape" && articleModal?.classList.contains("active")) {
        closeModal();
      }
      // Navigation keys
      if (articleModal?.classList.contains("active")) {
        if (e.key === "ArrowRight" || e.key === " ") {
          e.preventDefault();
          goToNextArticle();
        } else if (e.key === "ArrowLeft") {
          e.preventDefault();
          goToPrevArticle();
        }
      }
    });

    // Close on outside click
    if (articleModal) {
      articleModal.addEventListener("click", (e: MouseEvent) => {
        if (e.target === articleModal) {
          closeModal();
        }
      });
    }

    // Enhanced swipe support
    let touchStartX: number = 0;
    let touchEndX: number = 0;
    let touchStartY: number = 0;
    let touchEndY: number = 0;
    let isSwiping: boolean = false;

    if (articleModal) {
      articleModal.addEventListener(
        "touchstart",
        (e: TouchEvent) => {
          touchStartX = e.changedTouches[0].screenX;
          touchStartY = e.changedTouches[0].screenY;
          isSwiping = true;
        },
        { passive: true }
      );

      articleModal.addEventListener(
        "touchmove",
        (e: TouchEvent) => {
          if (!isSwiping) return;

          const currentX = e.changedTouches[0].screenX;
          const currentY = e.changedTouches[0].screenY;

          // Check if this is more of a vertical scroll than horizontal swipe
          const deltaX = Math.abs(currentX - touchStartX);
          const deltaY = Math.abs(currentY - touchStartY);

          if (deltaY > deltaX) {
            // This is vertical scrolling, not swiping
            isSwiping = false;
          }
        },
        { passive: true }
      );

      articleModal.addEventListener("touchend", (e: TouchEvent) => {
        if (!isSwiping) return;

        touchEndX = e.changedTouches[0].screenX;
        touchEndY = e.changedTouches[0].screenY;

        // Ensure this was actually a swipe and not a tap
        const deltaX = touchStartX - touchEndX;
        const deltaY = Math.abs(touchStartY - touchEndY);
        const swipeThreshold = 50;

        if (Math.abs(deltaX) > swipeThreshold && deltaY < swipeThreshold * 2) {
          e.preventDefault();
          handleSwipe(deltaX);
        }

        isSwiping = false;
      });

      // Prevent pull-to-refresh on mobile and body scroll
      articleModal.addEventListener(
        "touchmove",
        (e: TouchEvent) => {
          e.preventDefault();
        },
        { passive: false }
      );
    }

    function handleSwipe(deltaX: number): void {
      if (deltaX > 0) {
        // Swipe left - next article
        goToNextArticle();
      } else {
        // Swipe right - previous article
        goToPrevArticle();
      }
    }

    // Add visual feedback for swipe
    const addSwipeVisualFeedback = (): void => {
      const feedbackDiv = document.createElement("div");
      feedbackDiv.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 100px;
        height: 100px;
        pointer-events: none;
        z-index: 10001;
        display: none;
      `;

      const arrow = document.createElement("div");
      arrow.style.cssText = `
        width: 100%;
        height: 100%;
        border: 2px solid rgba(255, 255, 255, 0.7);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        background: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(10px);
      `;

      feedbackDiv.appendChild(arrow);
      document.body.appendChild(feedbackDiv);

      // Listen for swipe to show feedback
      if (articleModal) {
        articleModal.addEventListener("touchstart", () => {
          feedbackDiv.style.display = "block";
          feedbackDiv.style.opacity = "0";
        });

        articleModal.addEventListener("touchmove", (e) => {
          if (!isSwiping) return;

          const deltaX = e.touches[0].screenX - touchStartX;

          if (Math.abs(deltaX) > 20) {
            feedbackDiv.style.opacity = "1";
            arrow.innerHTML = deltaX > 0 ? "→" : "←";
            arrow.style.fontSize = "32px";
            arrow.style.color = "white";
          }
        });

        articleModal.addEventListener("touchend", () => {
          setTimeout(() => {
            feedbackDiv.style.display = "none";
          }, 200);
        });
      }
    };

    // Initialize visual feedback
    addSwipeVisualFeedback();
  });
</script>
